import os.path
import yaml
from datetime import datetime

YAMLPATH = "commonData.yaml"
PROJECT_ROOT = os.path.dirname(os.getcwd())

#CPP_OUTPUTPATH = "generated/cpptest.h"
CPP_OUTPUTPATH = os.path.join(PROJECT_ROOT,'arduino','panotroller',
    'include','GeneratedConstants.h')

#JAVA_OUTPUTPATH = "generated/javatest.java"
JAVA_OUTPUTPATH = os.path.join(PROJECT_ROOT,'android','app','src','main',
    'java','com','example','panotroller','GeneratedConstants.java')
print(CPP_OUTPUTPATH)

# to avoid destructive overwriting, move current version to a timestamped copy
if os.path.exists(CPP_OUTPUTPATH):
    output_split = CPP_OUTPUTPATH.split(".")
    if len(output_split) > 2:
        print("Too many dots in path!")
        exit()
    current_time = (datetime.now()).strftime("%Y%m%d%H%M%S")
    os.rename(CPP_OUTPUTPATH,output_split[0]+current_time+"."+output_split[1])
cpp_file = open(CPP_OUTPUTPATH, "x")

if os.path.exists(JAVA_OUTPUTPATH):
    output_split = JAVA_OUTPUTPATH.split(".")
    if len(output_split) > 2:
        print("Too many dots in path!")
        exit()
    current_time = (datetime.now()).strftime("%Y%m%d%H%M%S")
    os.rename(JAVA_OUTPUTPATH,output_split[0]+current_time+"."+output_split[1])
java_file = open(JAVA_OUTPUTPATH, "x")


# hardcoded garbage - TODO make this better with file fragments?
cpp_file.writelines(["// *** GENERATED BY COMMON/GENERATEHEADERS.PY *** \n",
    "// Header file to store common communication information \n",
    "#include <Arduino.h> \n",
    "#ifndef GLOBAL_HEADER\n",
    "#define GLOBAL_HEADER\n"])

with open(YAMLPATH) as file:
    yaml_list = yaml.load(file, Loader = yaml.FullLoader)

# generate CPP file

for item in yaml_list:
    item_list = yaml_list[item]
    if item == 'instructions':
        cpp_file.writelines(["// ** BEGIN INSTRUCTION DEFINITIONS **\n",
        "typedef enum {\n"])
        for instruction_pair in item_list[:-1]:
            for key in instruction_pair:
                print(key)
                inst = instruction_pair[key]
                cpp_file.writelines(["\t// Instruction pair: "+key+"\n",
                    "\t"+inst['android_string']+" = "+inst['android_code']+",\n",
                    "\t"+inst['arduino_string']+" = "+inst['arduino_code']+",\n"])
        for key in item_list[-1]:
            print(key)
            inst = item_list[-1][key]
            cpp_file.writelines(["\t// Instruction pair: "+key+"\n",
                "\t"+inst['android_string']+" = "+inst['android_code']+",\n",
                "\t"+inst['arduino_string']+" = "+inst['arduino_code']+"\n"])
        cpp_file.write("} instr_code;\n\n")
    else:
        cpp_file.writelines(["#define "+item_list['string']+" "+item_list['code']+"\n"])
cpp_file.write("\n#endif")
cpp_file.close()

# generate Java file

java_file.writelines(["// *** GENERATED BY COMMON/GENERATEHEADERS.PY *** \n",
    "// Class file to store common communication information \n",
    "package com.example.panotroller;\n",
    "// ** BEGIN CONSTANT DEFINITIONS **\n",
    "public class GeneratedConstants {\n"])
for item in yaml_list:
    item_list = yaml_list[item]
    if item == 'instructions':
        java_file.writelines(["\t// ** BEGIN INSTRUCTION DEFINITIONS **\n"])
        for instruction_pair in item_list:
            for key in instruction_pair:
                print(key)
                inst = instruction_pair[key]
                java_file.writelines(["\t// Instruction pair: "+key+"\n",
                    "\t"+"public final static byte "+inst['android_string']+
                        " = (byte) "+inst['android_code']+";\n",
                    "\t"+"public final static byte "+inst['arduino_string']+
                        " = (byte) "+inst['arduino_code']+";\n"])
        java_file.write("\n")
    else:
        java_file.write("\t// Other value: "+key+"\n")
        java_file.write("\tpublic final static "+item_list['type']+
            " "+item_list['string']+" = ("+item_list['type']+") "+
            item_list['code']+";\n\n")
java_file.write("}\n")
java_file.close()
